---------------------------Array-----------------------------------------
Basic:
1) isArraySorted: Input: N = 5, array[] = {1,2,3,4,5}, Output: True
2) largest element in array: Input: arr[] = {2,5,1,3,0}; Output: 5
3) linear search: Input: arr[]= 1 2 3 4 5, num = 3, Output: 2
4) reverse array
5) left rotate array by one: Input: N = 5, array[] = {1,2,3,4,5}, Output: 2,3,4,5,1
6) remove duplicates from unsorted array: Input: arr[]={2,3,1,9,3,1,3,9}, Output:  {2,3,1,9}

Easy:
1) Find maximum in given array.
2) Print the leaders from given array.
3) Reverse array elements.
4) Remove duplicates from sorted array in place such that each unique element appears ->[1,1,2,2,2,3,3], o/p:arr[1,2,3,_,_,_,_] 
5) Remove duplicates from unsorted array.
6) Reverse interger 
7) Find maximum consecutive one's. Input: prices = {1, 1, 0, 1, 1, 1} and Output: 3
8) Majority element: Return an element that occurs more than N/2 times in the given array.
9) Majority element: Return an element that occurs more than N/3 times in the given array.
10) 2_Sum problem: Input Format: N = 5, arr[] = {2,6,5,8,11}, target = 14 and O/p: [1, 3] (for 2nd variant).
11) Stock_Buy_Shell: Given array prices, return max profit w/ 1 buy & 1 sell
    Ex. prices = [7,1,5,3,6,4] -> 5 (buy at $1, sell at $6)
    For each, get diff b/w that & min value before, store max
12) Plus one problem: Explanation: The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be [1,2,4].

Medium:
1) Find duplicate element in array:  arr = {1,3,4,2,2}; o/p: 2
2) Sort array which contains number: 0, 1 & 2
3) Find repeating and missing number from given array
4) Maximum subarray sum/Kadane algorithm
5) Longest consecutive sequence {Input: [100, 200, 1, 3, 2, 4] , Output: 4
Explanation: The longest consecutive subsequence is 1, 2, 3, and 4.
6) Majority element (n/3): Example: Input: nums = [3,2,3], Output: [3]
7) longest_subarray_zero_sum: Input: A[] = {15,-2,2,-8,1,7,10,23}, Output: 5, Explanation: The largest subarray with
sum 0 will be -2 2 -8 1 7.
8) count_inversions_array: Input Format: N = 5, array[] = {5,4,3,2,1}
Result: 10
Explanation: we have a reverse sorted array and we will get the maximum inversions as for i < j we will always find a pair such that A[j] < A[i]. Example: 5 has index 0 and 3 has index 2 now (5,3) pair is inversion as 0 < 2 and 5 > 3 which will satisfy out conditions and for reverse sorted array we will get maximum inversions and that is (n)*(n-1) / 2.For above given array there is 4 + 3 + 2 + 1 = 10 inversions.
9) 3 sum: 

Hard:
1) Trapping rain water problem
2) Count reverse pairs

-------------------------2D Array -----------------------------------------------------------
1) Set Matrix Zeroes: Wherever 0 is found in matrix, corresponding row and column must be set to 0
2) Rotate image/matrix clockwise
3) Merge overlapping intervals: Ex: Input: intervals=[[1,3],[2,6],[8,10],[15,18]] and Output: [[1,6],[8,10],[15,18]]
4) Search in 2D matrix
5) Print pascal triangle
6) Merge two sorted array
7) Grid_unique_path
---------------------------Linked list--------------------------------------
Easy:
1) Check if linkedlist is palindrome
2) Get middle node of linked list
3) Detect cycle in lined list
4) Merge two sorted linked list
5) Reverse the linked list
6) Find intersection of two linked list

Medium:
1) Remove nth node from the end of linked list
2) Given the head of a sorted linked list, delete all duplicates such that each 
  element appears only once. Return the linked list sorted as well. Input: head = [1,1,2], Output: [1,2]
3) Given the head of a sorted linked list, delete all nodes that have duplicate numbers, 
   leaving only distinct numbers from the original list. Return the linked list sorted as well.
   Input: head = [1,2,3,3,4,4,5] , Output: [1,2,5]
4) Detect cycle started position in linked list
5) Add two numbers from given two linked list
6) Flatten the linked list
7) Delete given node in linked list
8) Rotate linked list: Input: head = [1,2,3,4,5], k = 2 , Output: [4,5,1,2,3]
9) Clone linked list with random and next pointer

-------------------------------Stack&Queue-------------------------------------------------------
Easy:
1) Stack Implementation Using Array
2) Implement queue using Array
3) Implement Stack using Queues
4) Implement Queue using Stacks
5) Implement Stack using linked list
6) Implement Queue using linked list
7) Valid Parentheses
8) Next Greater Element I

Medium:
1) Min stack implementation
2) LRU cache 
3) Rotten oranges problem

Hard:
1) Area_of_largest_rectangle_in_histogram
---------------------------String-----------------------------------------------------------------
Easy:
1) Strings anagram
2) Reverse string
3) Longest common prefix
4) Check if string is palindrome
5) Convert roman to integer
6) Remove All Duplicates from a String: Input: bcabc, output: bca
7) Permutations of a given string: Input: ABC, Output: ABC ACB BAC BCA CAB CBA
8) Recursively remove all adjacent duplicates: Input: s = "abbaca" , Output: "ca"	
9) str_str() implementation

Medium:
1) Atoi implementation
2) count and say problem
3) Minimum characters to be added at front to make string palindrome
4) Reverse words in string
5) Longest substring without repeat: Input: “ABCDEFGABEF”
Output: 7, Explanation: The longest substring without repeating characters are “ABCDEFG”, “BCDEFGA”, and “CDEFGAB” with lengths of 7
6) Z-Algorithm
7) Rabin karp algorithm

Hard:
1) KMP Algorithm

-------------------------------Binary Tree-------------------------------------------
Easy:
1) Binary Tree Inorder Traversal(Recursive and Iterative)
2) Binary Tree Preorder Traversal(Recursive and Iterative)
3) Binary Tree Postorder Traversal(Recursive and Iterative)
4) Morris traversal: Inorder traversal
5) Check for symmetrical Binary tree
6) Check for identical Binary tree
7) Max depth/Max height of Binary tree
8) Find the Diameter of Binary tree
9) Check for balanced Binary tree

Medium:
1) Top view of Binary tree
2) Bottom view of Binary tree
3) Left view of Binary tree
4) Right view of binary tree
5) Level order traversal of Binary tree
6) Zigzag traversal of Binary tree
7) Lowest common Ancestor 
8) Print root to node path in Binary tree
9) Construct Binary tree from Inorder and preorder traversal
10) Flatten binary tree

Hard:
1) Vertical traversal of Binary tree
2) Maximum path sum of Binary tree

------------------------------------








































-------------------Graph---------------------------------------------------------


