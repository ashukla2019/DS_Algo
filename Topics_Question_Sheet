---------------------------Array-----------------------------------------
Basic:
1) isArraySorted: Input: N = 5, array[] = {1,2,3,4,5}, Output: True
2) largest element in array: Input: arr[] = {2,5,1,3,0}; Output: 5
3) linear search: Input: arr[]= 1 2 3 4 5, num = 3, Output: 2
4) reverse array
5) left rotate array by one: Input: N = 5, array[] = {1,2,3,4,5}, Output: 2,3,4,5,1
6) remove duplicates from unsorted array: Input: arr[]={2,3,1,9,3,1,3,9}, Output:  {2,3,1,9}
7) find second largest/smallest element in array: Input: [1,2,4,7,7,5], Output: Second Smallest : 2

Easy:
1) find missing num in array: Input Format: N = 5, array[] = {1,2,4,5},Result: 3
2) Find the max number of consecutive one: Input: prices = {1, 1, 0, 1, 1, 1}, Output: 3
3) move all zeros to end: Input: 1 ,0 ,2 ,3 ,0 ,4 ,0 ,1, Output: 1 ,2 ,3 ,4 ,1 ,0 ,0 ,0
4) find number which appers once: Input Format: arr[] = {2,2,1}, Result: 1 
5) Remove duplicates from sorted array: Input: arr[1,1,2,2,2,3,3], Output: arr[1,2,3,_,_,_,_]
6) Reverse interger: Input: x = 123, Output: 321
7) 2_Sum problem: Input Format: N = 5, arr[] = {2,6,5,8,11}, target = 14 and O/p: [1, 3].
8) Plus one problem: Explanation: The array represents the integer 123.
    Incrementing by one gives 123 + 1 = 124.
    Thus, the result should be [1,2,4].
9)  union of two sorted array: n = 5,m = 5, arr1[] = {1,2,3,4,5},arr2[] = {2,3,4,4,5}, Output:  {1,2,3,4,5}
10) rotate array by k elements: Input: N = 7, array[] = {1,2,3,4,5,6,7} , k=2 , right
    Output: 6 7 1 2 3 4 5

Medium:
1) find leaders in array: arr = [4, 7, 1, 0], Output:  7 1 0
    Explanation:  Rightmost element is always a leader. 7 and 1 are greater than the elements in their right side.
2) Sort array which contains number: 0, 1 & 2: Input: nums = [2,0,2,1,1,0], Output: [0,0,1,1,2,2]
3) find_duplicate_in_array: Input: arr=[1,3,4,2,2], Output: 2
4) Maximum subarray sum/Kadane algorithm: Input: arr = [-2,1,-3,4,-1,2,1,-5,4] ,Output: 6 
    Explanation: [4,-1,2,1] has the largest sum = 6.

----start from medium
-------------------------2D Array -----------------------------------------------------------
1) Set Matrix Zeroes: Wherever 0 is found in matrix, corresponding row and column must be set to 0
2) Rotate image/matrix clockwise
3) Merge overlapping intervals: Ex: Input: intervals=[[1,3],[2,6],[8,10],[15,18]] and Output: [[1,6],[8,10],[15,18]]
4) Search in 2D matrix
5) Print pascal triangle
6) Merge two sorted array
7) Grid_unique_path
---------------------------Linked list--------------------------------------
Easy:
1) Check if linkedlist is palindrome
2) Get middle node of linked list
3) Detect cycle in lined list
4) Merge two sorted linked list
5) Reverse the linked list
6) Find intersection of two linked list

Medium:
1) Remove nth node from the end of linked list
2) Given the head of a sorted linked list, delete all duplicates such that each 
  element appears only once. Return the linked list sorted as well. Input: head = [1,1,2], Output: [1,2]
3) Given the head of a sorted linked list, delete all nodes that have duplicate numbers, 
   leaving only distinct numbers from the original list. Return the linked list sorted as well.
   Input: head = [1,2,3,3,4,4,5] , Output: [1,2,5]
4) Detect cycle started position in linked list
5) Add two numbers from given two linked list
6) Flatten the linked list
7) Delete given node in linked list
8) Rotate linked list: Input: head = [1,2,3,4,5], k = 2 , Output: [4,5,1,2,3]
9) Clone linked list with random and next pointer

-------------------------------Stack&Queue-------------------------------------------------------
Easy:
1) Stack Implementation Using Array
2) Implement queue using Array
3) Implement Stack using Queues
4) Implement Queue using Stacks
5) Implement Stack using linked list
6) Implement Queue using linked list
7) Valid Parentheses
8) Next Greater Element I

Medium:
1) Min stack implementation
2) LRU cache 
3) Rotten oranges problem

Hard:
1) Area_of_largest_rectangle_in_histogram
---------------------------String-----------------------------------------------------------------
Easy:
1) Strings anagram
2) Reverse string
3) Longest common prefix
4) Check if string is palindrome
5) Convert roman to integer
6) Remove All Duplicates from a String: Input: bcabc, output: bca
7) Permutations of a given string: Input: ABC, Output: ABC ACB BAC BCA CAB CBA
8) Recursively remove all adjacent duplicates: Input: s = "abbaca" , Output: "ca"	
9) str_str() implementation

Medium:
1) Atoi implementation
2) count and say problem
3) Minimum characters to be added at front to make string palindrome
4) Reverse words in string
5) Longest substring without repeat: Input: “ABCDEFGABEF”
Output: 7, Explanation: The longest substring without repeating characters are “ABCDEFG”, “BCDEFGA”, and “CDEFGAB” with lengths of 7
6) Z-Algorithm
7) Rabin karp algorithm

Hard:
1) KMP Algorithm

-------------------------------Binary Tree-------------------------------------------
Easy:
1) Binary Tree Inorder Traversal(Recursive and Iterative)
2) Binary Tree Preorder Traversal(Recursive and Iterative)
3) Binary Tree Postorder Traversal(Recursive and Iterative)
4) Morris traversal: Inorder traversal
5) Check for symmetrical Binary tree
6) Check for identical Binary tree
7) Max depth/Max height of Binary tree
8) Find the Diameter of Binary tree
9) Check for balanced Binary tree

Medium:
1) Top view of Binary tree
2) Bottom view of Binary tree
3) Left view of Binary tree
4) Right view of binary tree
5) Level order traversal of Binary tree
6) Zigzag traversal of Binary tree
7) Lowest common Ancestor 
8) Print root to node path in Binary tree
9) Construct Binary tree from Inorder and preorder traversal
10) Flatten binary tree

Hard:
1) Vertical traversal of Binary tree
2) Maximum path sum of Binary tree

------------------------------------








































-------------------Graph---------------------------------------------------------


