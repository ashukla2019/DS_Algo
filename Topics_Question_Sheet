---------------------------Array-----------------------------------------
Basic:
1) isArraySorted: Input: N = 5, array[] = {1,2,3,4,5}, Output: True
2) largest element in array: Input: arr[] = {2,5,1,3,0}; Output: 5
3) linear search: Input: arr[]= 1 2 3 4 5, num = 3, Output: 2
4) reverse array
5) left rotate array by one: Input: N = 5, array[] = {1,2,3,4,5}, Output: 2,3,4,5,1
6) remove duplicates from unsorted array: Input: arr[]={2,3,1,9,3,1,3,9}, Output:  {2,3,1,9}
7) find second largest/smallest element in array: Input: [1,2,4,7,7,5], Output: Second Smallest : 2

Easy:
1) find missing num in array: Input Format: N = 5, array[] = {1,2,4,5},Result: 3
2) Find the max number of consecutive one: Input: prices = {1, 1, 0, 1, 1, 1}, Output: 3
3) move all zeros to end: Input: 1 ,0 ,2 ,3 ,0 ,4 ,0 ,1, Output: 1 ,2 ,3 ,4 ,1 ,0 ,0 ,0
4) find number which appers once: Input Format: arr[] = {2,2,1}, Result: 1 
5) Remove duplicates from sorted array: Input: arr[1,1,2,2,2,3,3], Output: arr[1,2,3,_,_,_,_]
6) Reverse interger: Input: x = 123, Output: 321
7) 2_Sum problem: Input Format: N = 5, arr[] = {2,6,5,8,11}, target = 14 and O/p: [1, 3].
8) Plus one problem: Explanation: The array represents the integer 123.
    Incrementing by one gives 123 + 1 = 124.
    Thus, the result should be [1,2,4].
9)  union of two sorted array: n = 5,m = 5, arr1[] = {1,2,3,4,5},arr2[] = {2,3,4,4,5}, Output:  {1,2,3,4,5}
10) rotate array by k elements: Input: N = 7, array[] = {1,2,3,4,5,6,7} , k=2 , right
    Output: 6 7 1 2 3 4 5

Medium:
1) find leaders in array: arr = [4, 7, 1, 0], Output:  7 1 0
    Explanation:  Rightmost element is always a leader. 7 and 1 are greater than the elements in their right side.
2) Sort array which contains number: 0, 1 & 2: Input: nums = [2,0,2,1,1,0], Output: [0,0,1,1,2,2]
3) find_duplicate_in_array: Input: arr=[1,3,4,2,2], Output: 2
4) Maximum subarray sum/Kadane algorithm: Input: arr = [-2,1,-3,4,-1,2,1,-5,4] ,Output: 6 
    Explanation: [4,-1,2,1] has the largest sum = 6.
5) stock buy & sell: Input: prices = [7,1,5,3,6,4], Output: 5
    Explanation: Buy on day 2 (price = 1) and 
    sell on day 5 (price = 6), profit = 6-1 = 5.
6)  search in 2D matrix: Input Format: N = 3, M = 4, target = 8,
    mat[] = 1 2 3 4
            5 6 7 8 
            9 10 11 12
    Result: true
7) Rotate matrix 90 degree: Input: [[1,2,3],[4,5,6],[7,8,9]], Output: [[7,4,1],[8,5,2],[9,6,3]]
    Explanation: Rotate the matrix simply by 90 degree clockwise and return the matrix.
8) pascal triangle: Given the row number n. Print the n-th row of Pascal’s triangle.

Hard:
1) Given an array of numbers, you need to return the count of reverse pairs. 
   Reverse Pairs are those pairs where i<j and arr[i]>2*arr[j].
   Input: N = 5, array[] = {1,3,2,3,1), Output: 2 
   Explanation: The pairs are (3, 1) and (3, 1) as from both the pairs the condition arr[i] > 2*arr[j] is satisfied.
2) Count subarray with k sum: Input Format: N = 4, array[] = {3, 1, 2, 4}, k = 6, Result: 2
   Explanation: The subarrays that sum up to 6 are [3, 1, 2] and [2, 4].
3) Longest consecutive sequence: Input: [100, 200, 1, 3, 2, 4], Output: 4
   Explanation: The longest consecutive subsequence is 1, 2, 3, and 4.
4) longest sum with k sum: Input Format: N = 3, k = 5, array[] = {2,3,5}, Result: 2
   Explanation: The longest subarray with sum 5 is {2, 3}. And its length is 2.
5) Majority element(n/2): Input Format: N = 3, nums[] = {3,2,3}, Result: 3
   Explanation: When we just count the occurrences of each number and compare with half of the size of the array, you will get 3 for the above solution. 
6) Majority element(n/3):Input Format: N = 5, array[] = {1,2,2,3,2}, Result: 2
   Explanation: Here we can see that the Count(1) = 1, Count(2) = 3 and Count(3) = 1.Therefore, the count of 2 is greater than N/3 times. Hence, 2 is the answer.
7) Merge overlapping subproblems: Input: intervals=[[1,3],[2,6],[8,10],[15,18]]
   Output: [[1,6],[8,10],[15,18]]
   Explanation: Since intervals [1,3] and [2,6] are overlapping we can merge them to form [1,6] intervals.
8) Merge two sorted array: n = 4, arr1[] = [1 4 8 10] , m = 5, arr2[] = [2 3 9]
   Output: 
   arr1[] = [1 2 3 4]
   arr2[] = [8 9 10]
   Explanation: After merging the two non-decreasing arrays, we get, 1,2,3,4,8,9,10.
9) set matrix zero: Input: matrix=[[1,1,1],[1,0,1],[1,1,1]]
   Output: [[1,0,1],[0,0,0],[1,0,1]]
   Explanation: Since matrix[2][2]=0.Therfore the 2nd column and 2nd row wil be set to 0.
10) Trapped rain water: Input: height= [0,1,0,2,1,0,1,3,2,1,2,1]
    Output: 6
    Explanation: As seen from the diagram 1+1+2+1+1=6 unit of water can be trapped

Expert:
1) 3_sum: Input: nums = [-1,0,1,2,-1,-4], Output: [[-1,-1,2],[-1,0,1]]
  Explanation: Out of all possible unique triplets possible, [-1,-1,2] and [-1,0,1] satisfy the condition of summing up to zero with i!=j!=k
2) 4_sum: Input Format: arr[] = [1,0,-1,0,-2,2], target = 0
   Result: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
   Explanation: We have to find unique quadruplets from the array such that the sum of those elements is equal to the target sum given that is 0. The result obtained is such that the sum of the quadruplets yields 0.

---------------------------Linked list--------------------------------------
Easy:
1) Check if linkedlist is palindrome
2) Get middle node of linked list
3) Detect cycle in lined list
4) Merge two sorted linked list
5) Reverse the linked list
6) Find intersection of two linked list

Medium:
1) Remove nth node from the end of linked list
2) Given the head of a sorted linked list, delete all duplicates such that each 
  element appears only once. Return the linked list sorted as well. Input: head = [1,1,2], Output: [1,2]
3) Given the head of a sorted linked list, delete all nodes that have duplicate numbers, 
   leaving only distinct numbers from the original list. Return the linked list sorted as well.
   Input: head = [1,2,3,3,4,4,5] , Output: [1,2,5]
4) Detect cycle started position in linked list
5) Add two numbers from given two linked list
6) Flatten the linked list
7) Delete given node in linked list
8) Rotate linked list: Input: head = [1,2,3,4,5], k = 2 , Output: [4,5,1,2,3]
9) Clone linked list with random and next pointer

-------------------------------Stack&Queue-------------------------------------------------------
Easy:
1) Stack Implementation Using Array
2) Implement queue using Array
3) Implement Stack using Queues
4) Implement Queue using Stacks
5) Implement Stack using linked list
6) Implement Queue using linked list
7) Valid Parentheses
8) Next Greater Element I

Medium:
1) Min stack implementation
2) LRU cache 
3) Rotten oranges problem

Hard:
1) Area_of_largest_rectangle_in_histogram
---------------------------String-----------------------------------------------------------------
Easy:
1) Strings anagram
2) Reverse string
3) Longest common prefix
4) Check if string is palindrome
5) Convert roman to integer
6) Remove All Duplicates from a String: Input: bcabc, output: bca
7) Permutations of a given string: Input: ABC, Output: ABC ACB BAC BCA CAB CBA
8) Recursively remove all adjacent duplicates: Input: s = "abbaca" , Output: "ca"	
9) str_str() implementation

Medium:
1) Atoi implementation
2) count and say problem
3) Minimum characters to be added at front to make string palindrome
4) Reverse words in string
5) Longest substring without repeat: Input: “ABCDEFGABEF”
Output: 7, Explanation: The longest substring without repeating characters are “ABCDEFG”, “BCDEFGA”, and “CDEFGAB” with lengths of 7
6) Z-Algorithm
7) Rabin karp algorithm

Hard:
1) KMP Algorithm

-------------------------------Binary Tree-------------------------------------------
Easy:
1) Binary Tree Inorder Traversal(Recursive and Iterative)
2) Binary Tree Preorder Traversal(Recursive and Iterative)
3) Binary Tree Postorder Traversal(Recursive and Iterative)
4) Morris traversal: Inorder traversal
5) Check for symmetrical Binary tree
6) Check for identical Binary tree
7) Max depth/Max height of Binary tree
8) Find the Diameter of Binary tree
9) Check for balanced Binary tree

Medium:
1) Top view of Binary tree
2) Bottom view of Binary tree
3) Left view of Binary tree
4) Right view of binary tree
5) Level order traversal of Binary tree
6) Zigzag traversal of Binary tree
7) Lowest common Ancestor 
8) Print root to node path in Binary tree
9) Construct Binary tree from Inorder and preorder traversal
10) Flatten binary tree

Hard:
1) Vertical traversal of Binary tree
2) Maximum path sum of Binary tree

------------------------------------








































-------------------Graph---------------------------------------------------------


